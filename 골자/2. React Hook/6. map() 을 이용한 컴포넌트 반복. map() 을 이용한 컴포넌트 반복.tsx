// (실습)
// 이제 많은 데이터를 받아서, 컴포넌트를 반복해보겠습니다
// 이전 프로젝트에서 계속 이어서 작업할게요
// 먼저 컴포넌트 파일에서 데이터를 작성해서 쓰지 않고
// 데이터가 있는 파일을 따로 만들도록 할게요
// src 안에 파일명은 데이터 닷 제이슨
// 만들어서, 저는 만들어둔게 있어서 그대로 붙여넣을게요
{
	"data": {
		"students": [
			{
				"id": 0,
				"name": "조교행님",
				"age": 28,
				"isGirlfriend": true
			},
			{
				"id": 1,
				"name": "지수",
				"age": 22,
				"isGirlfriend": true
			},
			{
				"id": 2,
				"name": "펭수",
				"age": 5,
				"isGirlfriend": false
			}
		]
	}
}

// 제이슨은 백엔드에서 프론트엔드로 데이터를 넘겨줄 때
// 가장 많이 사용되는 양식 (form) 입니다
// 백엔드에 우리가 요청을 주면
// 데이터는 이런식으로 받는다고 생각하시면 되요
// 그래서 프론트엔드 개발할때는
// 백엔드 개발자가 코드를 만들때까지 기다리지 않고
// 백엔드코드와 연동하기전에
// 스스로 이런 샘플데이터를 만들어놓은다음에
// 화면을 만들어나갑니다
// 구조를 자세히 보면
// 자바스크립트 객체와 매우 비슷하게 생겼어요
// 다른점으로, 필드에도 쌍따옴표가 들어가죠?
// 참고로 제이슨은 매우 엄격한 문법을 사용하기때문에
// 콤마 하나, 괄호 하나 틀리면 앱 전체가 안돌아갈수도 있어요
// 이 데이터를 써서 코드를 작성해보죠
// 데이터에 푸는 없기때문에
// 스튜던트 닷 티에스엑스의 인터페이스에서 푸는 빼버리겠습니다
// 앱 닷 티에스엑스에서도 빼줄게요

// 근데 스튜던트 닷 티에스엑스에서 보면
// 데이터닷제이슨과 화면분할할게요
// 데이터닷제이슨에는 아이디가 있었는데
// 인터페이스엔 안써놨죠?
// 왜냐면 스튜던트 컴포넌트에선 아이디를 쓰지 않을것이기
// 때문이에요
// 인터페이스는 해당 컴포넌트에서 사용할것만 쓰면 됩니다
// 근데 여러분들은 타입스크립트를 사용할 것이기 때문에
// 추가적인 설정을 하나 더 해줄거에요
// 백엔드에서 바로 받을땐 상관이 없는데
// 우리가 샘플데이터를 제이슨으로 만들어서 쓸 경우엔
// 설정을 한가지 더 해줘야합니다
// 파일 네비게이션 보면
// 티에스콘피그닷제이슨
// 일단 수정한거 다 저장한 다음에
// 화면분할 해제하고 티에스닷콘피그제이슨 열어줄게요
// 여기에서 컴파일러 옵션 제이에스엑스 밑에
// 다음과 같이 추가해줄게요
// 콤마찍고
"resolveJsonModule": true
// 콤마 안찍는 실수를 굉장히 자주한다그랬죠
// 객체에서 프로퍼티를 이어서 추가할땐 뒷줄에 콤마를
// 넣어줘야합니다

// 그리고 데이터는 어디서 관리한다했죠? 
// 앱에서 관리합니다. 앱닷티에스엑스로 가서
// 임포트 중괄호 치고 데이터 프롬 데이터 닷 제이슨
// 왜 데이터냐면
// 데이터닷제이슨 켜보면
// 데이터로 시작하는 부분을 우리가 가져올거거든요
// 나중에 백엔드하고 연동할때 특히 신경써야할 부분인데
// 우린 데이터가 어떤 형태로 들어오는지 알고 써야되요
// 맨 처음에 무엇으로 시작합니까?
// 데이터로 시작하죠
// 데이터의 타입은 뭡니까?
// 중괄호로 쓰였으니깐 객체죠
// 그 안에 뭐가있어요?
// 스튜던스라는 배열이 있죠
// 배열의 각 요소, 엘리먼트의 타입은 뭡니까?
// 객체죠
// 그 객체는 무슨 프로퍼티로 구성되어있습니까?
// 아이디, 네임, 에이지, 이즈걸프렌드
// 각각의 자료형은? 넘버, 스트링, 넘버, 불리언이네요

// 우리가 백엔드로부터 데이터를 받을때는,
// 이처럼 뭘 받을지 그 구조를 정확히 알고있어야합니다
// 이 데이터는 결국 프론트에서 받기때문에
// 백엔드 개발자가 정확히 뭘 넘겨줬으면 좋겠는지
// 문서화해서 백엔드 개발자한테 주문하는 방법이
// 사실 가장 좋지 않을까 생각드네요
// 어쨌든 콘솔로그로 찍어보죠
// 앱으로 가서
// 콘솔로그 데이터 확인해볼게요
// 데이터 닷 스튜던스
// 잘 들어온것을 확인할 수 있습니다

// 이제 반복을 해볼 모든 준비가 끝났습니다.

// 맵을 이용해 컴포넌트를 여러개 만들어볼거에요
// 타입스크립트 수업때 맵을 설명했는데
// 까먹은 학생들을 위해 핵심만 잠깐 설명하자면
// 맵은 배열의 엘리먼트를 반복해서, 조작하여,
// 새로운 배열을 만드는 함수입니다
// 우리의 데이터였던 마이인포를 지우고요
import "./styles.css";
import Student from "./Student";
import { data } from "./data.json";

console.log(data.students);

export default function App() {
  return (
    <div className="App">
      {data.students.map((student) => (
        <Student
          key={student.id}
          name={student.name}
          age={student.age}
          isGirlfriend={student.isGirlfriend}
        />
      ))}
    </div>
  );
}

// 이렇게 바꿔주도록 할게요
// 데이터 객체의 스튜던스 복수 배열의 각 요소를
// 스튜던트 단수 라는 파라미터로 받고
// 출력결과를 스튜던트 컴포넌트로 리턴하는데
// 각각의 스튜던트 컴포넌트에 
// 프롭스로
// 이름 나이 이즈걸프렌드를 줄겁니다

// 근데 여기서 하나를 더 줄겁니다
// 키를 줄거에요
// 키는 뭐냐면, 반복에서 이걸 안써주면
// 리액트에서 키 에러가 발생하기때문에 써준거에요
// 왜? 리액트에서 모든 컴포넌트는
// 동일한 이름을 가졌더라도 유일한 존재여야하거든요
// 그래서 키를 통해 구분해줘야합니다
// 보통은 데이터의 아이디를 키로 씁니다
// 왜? 아이디는 각 데이터를 식별해주는 유일한 존재거든요
// 이 코드는 이렇게 짧게 줄일 수 있습니다

import "./styles.css";
import Student from "./Student";
import { data } from "./data.json";

console.log(data.students);

export default function App() {
  return (
    <div className="App">
      {data.students.map((student) => (
        <Student key={student.id} {...student} />
      ))}
    </div>
  );
}

// 키는 그대로 써줬구요
// 프롭스로 일일히 써줬던 것들을
// 이렇게 간단하게 줄일 수 있어요
// 이걸 프로퍼티 스프레드 노테이션이라고 하고
// 2018년에 자바스크립터에서 정식 문법으로 채택되었습니다
// 이걸 쓸지말지는 개인 취향입니다
// 코드 짧게 쓰는게 좋은 사람은 이렇게
// 점 세개 붙여서 쓰면 되고,
// 정확하게 쓰고 싶은 사람은
// 첫번째 코드로 쓰면 됩니다
// 화면이 안이쁘기 때문에 구분을 위해서
// 제목만 좀 추가해보면 


// 데이터 닷 스튜던스 배열의 갯수는 총 몇개였습니까?
// 3개였죠
// 그래서 맵함수에 의해 3개의 컴포넌트가 만들어졌고
// 각자 다른 프롭스가 들어가서
// 다른 결과를 보여줍니다

// 물론 맵함수의 파라미터를 따로 빼서
// 새로운 함수로 분리할수도 있어요
// 앱 위에 써줄게요

import "./styles.css";
import Student from "./Student";
import { data } from "./data.json";

const renderStudent = (student) => (
  <Student key={student.id} {...student} />
);

export default function App() {
  return (
    <div className="App">
      <h1>App</h1>
      {data.students.map(renderStudent)}
    </div>
  );
}


// 그런데 이 경우엔 스튜던트에 들어갈 인터페이스를
// 따로 써줘야 작동합니다
interface StudentInfo {
  id: number;
  name: string;
  age: number;
  isGirlfriend: boolean;
}

// 함수를 따로 만들고 말고는
// 개발자가 개발 상황에 따라서 결정할 일입니다
// 지금같은경우는 함수가 매우 짧기때문에
// 분리를 하는것보다 그냥 맵함수 안에서
// 작성하는게 더 낫습니다

// (피피티)
// 핵심정리 읽어보겠습니다
// 프론트엔드에선 백엔드로부터 받을 데이터를 정확히 알고 있어야 한다.
// 컴포넌트를 반복할 땐 map() 을 사용하고, key 를 달아준다.