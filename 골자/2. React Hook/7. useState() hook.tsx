// 저번에도 말했지만,
// 리액트에서 주요한 기술은 딱 두가지입니다
// 첫번째가 컴포넌트
// 두번째가 훅입니다
// 즉, 훅까지 배우고 나면 리액트의 핵심기술은
// 다 배운겁니다

// (다음)
// 프론트엔드 개발자는 화면을 만들죠
// 화면의 데이터 변경이 일어나면
// 화면은 더이상 최신정보를 담고 있지 않기 때문에
// 사용자는 새로운 화면이 필요합니다
// 예를 들면 여기 로파이 걸이라는
// 페이스북 페이지가 있는데
// 제가 밑에 좋아요 버튼을 누르면?
// 다음과 같이 좋아요가 뜨면서
// 회원님 외 165명이 좋아한다고 바뀌었죠?
// 즉, 새로운 화면이 렌더, 한국어로 하면 그려진거에요
// 새로운 화면을 가져오는 전통적인 방법은 무엇일까요?
// 새로고침이죠
// 내가 새로고침하던지
// 아니면 클릭했을때 웹에서 자동으로 새로고침해서
// 새로운 페이지를 보여주던지
// 어쨌든 새로고침이 일어나게 됩니다
// 그러나, 데이터가 변경되었을 때,
// 새로고침 없이 즉각 화면을 다시 그릴 수 있다면
// 멋지지 않겠어요?
// 훅을 사용하면 이것이 가능합니다

// (다음)
// 훅은 대체 뭘까?
// 훅은 리액트 함수 컴포넌트에서만 쓰는 특별한 함수입니다
// 함수이름 앞에 use 가 붙어있으면 훅입니다

// (다음)
// 훅은 크게 세가지로 구분됩니다
// useState()
// useEffect()
// 그리고 기타 훅들. 우리가 직접 훅을 만들수도 있습니다.

// 첫번째, useState 훅부터 알아보겠습니다
// 그대로 읽어보면, 사용한다. 스테이트를.
// 근데 스테이트가 뭐지?
// 저번에 프롭스 설명할때
// 상태관리 라이브러리를 설명하면서
// 상태를 영어로 스테이트라고 한다고 했죠?
// 스테이트는, 함수가 끝나도 사라지지 않는 변수를 말합니다

// 컴포넌트의 데이터 저장소에요
// 한국어로 상태라고 하고
// 스테이트는 변합니다
// 지금까지 설명만 들어서는 도무지 감이 안잡히죠?
// 코드를 보면서 이해해봅시다.

// (실습)
// 새 리액트 타입스크립트 샌드박스를 만들겠습니다
// 간단한 카운터를 만들어볼거에요
// 카운터는 뭐냐
// 누르면 숫자가 증가하는걸 카운터라고 합니다
// 클래스네임 앱 안에 있는걸 다 지워버리고
// h1안에 App이라는것만 남겨놓겠습니다.
// 그리고 다음 코드를 써볼게요
// 이해하려 하지 말고 일단 써보세요

import { useState } from "react";
import "./styles.css";

export default function App() {
	const [count, setCount] = useState(0);
	return (
		<div className="App">
			<h1>App</h1>
			{count}
			<button onClick={() => setCount(count + 1)}>plus</button>
		</div>
	);
}

// 그리고 아무 생각하지 말고
// 저 플러스 버튼을 눌러보세요
// 숫자가 증가하죠?
// 계속 눌러보세요
// 일이삼사오륙칠팔
// 새로고침 누르면 다시 영으로 돌아오죠

// 옛날옛적엔 이거 누를때마다
// 새로고침되었거든요
// 근데 새로고침 발생했습니까
// 아니죠
// 새로고침없이 자연스럽게 데이터가 증가했죠

// 즉, 데이터가 바뀔때마다
// 정확히는 스테이트가 바뀔때마다
// 앱 컴포넌트는 새롭게 그려집니다
// 다른말로는 렌더링됩니다

// (ppt)
// 다시 순서대로 이해해봅시다
// 플러스 버튼 클릭하면
// 스테이트로 설정해둔 카운트가 0에서 1로 변경됩니다
// 스테이트는 데이터 저장소라고 했죠?
// 그리고 앱 컴포넌트를 다시 렌더링하는데
// 전체 다 렌더링하면 비효율적이죠?
// 카운터 부분만 다시 렌더링합니다
// useState 훅은 이런식으로 작동된다고 이해하면 됩니다
// 이제, 우리의 코드를 분석해보죠

// (실습)
// 첫번째라인
// 유즈스테이트 훅을 사용하고 싶으면
// 리액트에서 임포트해야됩니다
// 우리의 리액트 라이브러리에서
// 유즈스테이트 훅을 제공하는데
// 사용하고싶으면
// 임포트해야합니다
// 그리고 앱 안에 변수선언 봅시다
// 그 다음 앱 안에 있는
// 콘스트 변수 봅시다
// 배열을 리턴받죠?

// 리턴값 여러개 받을땐 이렇게 배열로 써서 받는다했어요
// 유즈 스테이트 훅에서 파라미터로 뭐가 들어갑니까
// 0이 들어갔네요
// 이건 초깃값입니다
// 만약에 이걸 5로 바꾼다면
// 5에서부터 시작할거에요
// 다시 0으로 돌려줄게요

// 즉, 카운트라는 콘스트 변수를 데이터 저장소인 스테이트로
// 등록하고
// 그걸 변경하는 방법인 셋카운트 함수를 같이 리턴받는겁니다
// 조금 있다가 그림으로 다시 설명드릴게요
// 근데 저번시간까지는 데이터를
// 컴포넌트 안이 아니라 바깥에 뒀잖아요

// 그럼 그렇게 한번 해볼까요
// 죽 긁어서
// 바깥에 두면
// 에러뜹니다
// 에러 읽어볼까요?
// hooks can only be called inside of the body of a
// function component
// 훅은 함수 컴포넌트 안에서만 콜 될수 있습니다

// (ppt)
// 리액트 공식문서에 보면
// 훅은 그냥 자바스크립트 함수일 뿐이기에
// 자유롭게 쓸 수 있지만
// 두가지 규칙을 제시했어요
// 최상위에서만 훅을 호출하라
// 반복문, 조건문, 중첩함수에선 훅을 쓰지 말라
// 두번째는 함수 컴포넌트에서만 훅을 호출하라
// 이것을 강제하기 위해 린터 플러그인
// 정확하게는 eslint 플러그인 리액트 훅스
// 에서, 이 규칙을 안 지켰을 경우에

// (코드)
// 다음과 같이 에러를 일으킵니다

// (다시 피피티)
// 린터는 에러체크하는 프로그램이라 생각하면 됩니다
// 이알 빼고 린트라고 하기도 해요
// 자바스크립트 세계에서 가장 많이 쓰는 린터는
// 이에스린트입니다
// 그래서, 우리는 이 규칙을 지켜줍시다
// 근데 왜 함수 컴포넌트 안에서만 쓸 수 있도록 했을까?
// 렌더링해야되니까요
// 그 컴포넌트를 다시 그려야되니까요
// 그리고, 클래스컴포넌트라고 있는데
// 제가 가르쳐주지 않은 컴포넌트 만드는 방식 있어요
// 일부러 안가르쳤는데
// 거기서도 훅 쓰면 안됩니다
// 함수 컴포넌트 안에서만 써야되요

// 클래스 컴포넌트 궁금하면
// 직접 검색해서 찾아보시면 좋을 것 같아요

// 저는 하지 않겠습니다
// 자바스크립트 타입스크립트에서도 클래스 가르친적없고
// 그렇게 했을 경우에 코딩을 쉽게 시작해보자라는
// 제 철학에서도 벗어나요
// 어쨌든 중요한건 
// 함수컴포넌트 안에서만 훅을 써야된다는 겁니다

// (코드)
// 다음, h1 태그 밑에보면
// 카운트 달아놨죠?
// 중괄호 써서 화면에 붙입니다
// 그리고
// 아랫쪽에 버튼 달아놨는데
// 이벤트 핸들러가 나왔네요
// 클릭을 하면,
// 셋카운트가 실행되고
// 파리미터로 카운트 플러스 일이 들어갑니다
// 이제 그림을 보면서 좀 더 자세히 분석해보겠습니다

// (피피티)
// 버튼 옆에 온클릭은 이벤트 핸들러입니다
// 1장 html에서 설명했듯이
// 이벤트핸들러는 리액트의 개념이 아니라
// 원래 html에 있는 개념입니다
// 이벤트와 이벤트 핸들러 뭐라고했죠?
// 이벤트(event)는 브라우저에서 일어나는 
// 사용자의 행동을 말합니다 
// 클릭, 드래그, 스크롤, 타이핑, 화면 사이즈 줄이기 등
// 여러분이 상상할 수 있는 모든 동작은 이벤트입니다
// on- 이 붙으면 이벤트 핸들러(event handler)를 의미하는데
// 이벤트 발생 시 동작하는 함수를 말합니다

// 리액트에선 html과 문법을 조금 다르게 씁니다
// 첫째, 온클릭이 아닌 온'클릭', 즉 낙타법 쓴다구요
// 둘째, 쌍따옴표 대신에 중괄호 씁니다

// (다음)
// 유즈스테이트 훅에서 핵심적인 두줄을 자세히 알아봅시다
// 카운트는 우리가 만든 스테이트입니다
// 카운트라고 이름이 정해진것이 아니에요
// 우리가 이름붙인겁니다
// 궁금하면 바나나로 바꿔봐도 잘 동작해요
// 그 옆에 있는 셋카운트는 카운트를 변경하는 함수입니다
// 관습적으로, 셋이라는 글자 다음에 담당하는
// 스테이트 이름을 적어줍니다
// 내멋대로 이름지어도 잘 동작하는데
// 이렇게 원칙적으로 이름지어주면
// 나중에 훨씬 관리하기 편하겠죠?
// 즉, 유즈스테이트라는 훅은
// 두가지 엘리먼트로 구성된 하나의 배열을 리턴하는데,
// 스테이트와
// 스테이트를 변경하는 함수입니다
// 그리고 유즈스테이트의 파라미터로 사용된 0은
// 우리의 스테이트인 카운트의 초깃값입니다
// 아까 보여줬죠? 5를 넣으면 5에서부터 시작하잖아요
// 온클릭 이벤트핸들러는
// 파라미터를 받지 않고
// 실행 시 리턴값으로 셋카운트 함수를
// 실행합니다
// 왜? 소괄호 썼잖아요
// 소괄호는 함수를 실행한다는 뜻이라 했잖아요
// 셋카운트 함수의 파라미터로
// 카운트를 어떻게 변경할지 그 내용이 들어갑니다
// 그리고 리액트는 화면전체가 아니라, 
// 바뀌는 그 부분만 다시 렌더링합니다
// 전체 실행과정을 다시 생각해보면
// 버튼 클릭하면 스테이트로 설정한
// 카운트가 변경되고
// 해당 부분만 다시 렌더링됩니다
// 즉, 새로고침 없이 부드럽게 스테이트가 변경되는것을
// 확인할 수 있습니다
// 이렇게 동작하는게
// 마치 설치된 프로그램(다른말로는 네이티브 앱)처럼
// 동작한다고 해서
// 웹앱이라고 부르는 겁니다
// 웹앱 이전에 웹개발은, 고급 개발자로 취급 안해주는 
// 분위기가 있었어요 특히 프론트엔드개발자
// 웹개발자는 그냥 짜져있으세요 이런 얘기도 있었고
// 프론트? 그거 그냥 디자이너 아니야?
// 이런얘기도 있었어요
// 웹앱 시대 이후로 

// 정확하게는 에이젝스가 등장하고 나서입니다
// 리액트 훅이 이 시대를 연게 아니에요
// 에이젝스라는 기술이 나오고
// 구글 지도, 구글 어스라는 게 나온 이후로
// 다른 개발자들이 깜짝 놀라게 됐어요
// 아니, 자바스크립트로 이런 게 가능해?

// 돌아가는 환경만 브라우저일 뿐인
// 네이티브 수준의 웹을
// 또는 브라우저를 벗어나서 
// 진짜 네이티브 앱을 만들수 있게 되었기때문에
// 개발자 대우를 해주지 않나 생각들어요
// 일단, 유즈스테이트 훅이 뭔지는 알아봤으니
// 시간도 지났고 해서 다음영상으로 넘어가겠습니다
// 
